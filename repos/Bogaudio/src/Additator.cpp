
#include "Additator.hpp"

void Additator::onReset() {
	_syncTrigger.reset();
	_steps = modulationSteps;
	_phase = PHASE_RESET;
}

void Additator::onSampleRateChange() {
	_oscillator.setSampleRate(engineGetSampleRate());
	_steps = modulationSteps;
	_phase = PHASE_RESET;
}

float Additator::cvValue(Input& cv, bool dc) {
	if (!cv.active) {
		return dc ? 1.0f : 0.0f;
	}
	if (dc) {
		return clamp(cv.value / 10.0f, 0.0f, 1.0f);
	}
	return clamp(cv.value / 5.0f, -1.0f, 1.0f);
}

void Additator::step() {
	lights[SINE_LIGHT].value = _phase == PHASE_SINE;
	lights[COSINE_LIGHT].value = _phase == PHASE_COSINE;
	if (!outputs[AUDIO_OUTPUT].active) {
		return;
	}

	++_steps;
	if (_steps >= modulationSteps) {
		_steps = 0;

		float width = clamp(params[WIDTH_PARAM].value + (maxWidth / 2.0f) * cvValue(inputs[WIDTH_INPUT]), 0.0f, maxWidth);
		float oddSkew = clamp(params[ODD_SKEW_PARAM].value + cvValue(inputs[ODD_SKEW_INPUT]), -maxSkew, maxSkew);
		float evenSkew = clamp(params[EVEN_SKEW_PARAM].value + cvValue(inputs[EVEN_SKEW_INPUT]), -maxSkew, maxSkew);
		if (
			_width != width ||
			_oddSkew != oddSkew ||
			_evenSkew != evenSkew
		) {
			_width = width;
			_oddSkew = oddSkew;
			_evenSkew = evenSkew;

			float multiple = 1.0f;
			_oscillator.setPartialFrequencyRatio(1, multiple);
			for (int i = 2, n = _oscillator.partialCount(); i <= n; ++i) {
				float ii = i;
				if (i % 2 == 0) {
					ii += _evenSkew;
				}
				else {
					ii += _oddSkew;
				}
				_oscillator.setPartialFrequencyRatio(i, powf(ii, _width));
			}
		}

		int partials = clamp((int)roundf(params[PARTIALS_PARAM].value * cvValue(inputs[PARTIALS_INPUT], true)), 0, maxPartials);
		float amplitudeNormalization = clamp(params[GAIN_PARAM].value + ((maxAmplitudeNormalization - minAmplitudeNormalization) / 2.0f) * cvValue(inputs[GAIN_INPUT]), minAmplitudeNormalization, maxAmplitudeNormalization);
		float decay = clamp(params[DECAY_PARAM].value + ((maxDecay - minDecay) / 2.0f) * cvValue(inputs[DECAY_INPUT]), minDecay, maxDecay);
		float balance = clamp(params[BALANCE_PARAM].value + cvValue(inputs[BALANCE_INPUT]), -1.0f, 1.0f);
		float filter = clamp(params[FILTER_PARAM].value + cvValue(inputs[FILTER_INPUT]), minFilter, maxFilter);
		if (
			_partials != partials ||
			_amplitudeNormalization != amplitudeNormalization ||
			_decay != decay ||
			_balance != balance ||
			_filter != filter
		) {
			int envelopes = _partials != partials ? std::max(_partials, partials) : 0;
			_partials = partials;
			_amplitudeNormalization = amplitudeNormalization;
			_decay = decay;
			_balance = balance;
			_filter = filter;

			float as[maxPartials + 1];
			float total = as[1] = 1.0f;
			filter = log10f(_filter) + 1.0f;
			for (int i = 2, n = _oscillator.partialCount(); i <= n; ++i) {
				as[i] = 0.0f;
				if (i <= _partials) {
					as[i] = powf(i, -_decay) * powf(_filter, i);
					if (i % 2 == 0) {
						if (_balance > 0.0f) {
							as[i] *= 1.0f - _balance;
						}
					}
					else {
						if (_balance < 0.0f) {
							as[i] *= 1.0f + _balance;
						}
					}
					total += as[i];
				}
			}
			total /= _amplitudeNormalization;
			for (int i = 1, n = _oscillator.partialCount(); i <= n; ++i) {
				as[i] /= total;
				_oscillator.setPartialAmplitude(i, as[i], i <= envelopes);
			}
		}

		float frequency = params[FREQUENCY_PARAM].value;
		if (inputs[PITCH_INPUT].active) {
			frequency += inputs[PITCH_INPUT].value;
		}
		frequency = clamp(cvToFrequency(frequency), 50.0f, 10000.0f);
		_oscillator.setFrequency(frequency);

		if (_syncTrigger.process(inputs[SYNC_INPUT].value)) {
			_oscillator.syncToPhase(_phase == PHASE_SINE ? 0.0f : M_PI / 2.0f);
		}
		Phase phase = ((int)params[PHASE_PARAM].value) == 2 ? PHASE_COSINE : PHASE_SINE;
		if (_phase != phase) {
			_phase = phase;
			_oscillator.syncToPhase(_phase == PHASE_SINE ? 0.0f : M_PI / 2.0f);
		}
	}

	outputs[AUDIO_OUTPUT].value = _oscillator.next() * 5.0;
}

struct AdditatorWidget : ModuleWidget {
	AdditatorWidget(Additator* module) : ModuleWidget(module) {
		box.size = Vec(RACK_GRID_WIDTH * 20, RACK_GRID_HEIGHT);

		{
			SVGPanel *panel = new SVGPanel();
			panel->box.size = box.size;
			panel->setBackground(SVG::load(assetPlugin(plugin, "res/Additator.svg")));
			addChild(panel);
		}

		addChild(Widget::create<ScrewSilver>(Vec(15, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 30, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(15, 365)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 30, 365)));

		// generated by svg_widgets.rb
		auto frequencyParamPosition = Vec(40.5, 50.5);
		auto partialsParamPosition = Vec(120.5, 50.5);
		auto widthParamPosition = Vec(200.5, 50.5);
		auto oddSkewParamPosition = Vec(250.5, 36.5);
		auto evenSkewParamPosition = Vec(250.5, 76.5);
		auto gainParamPosition = Vec(40.5, 130.5);
		auto decayParamPosition = Vec(120.5, 130.5);
		auto balanceParamPosition = Vec(200.5, 130.5);
		auto filterParamPosition = Vec(250.5, 130.5);
		auto phaseParamPosition = Vec(179.0, 334.5);

		auto partialsInputPosition = Vec(13.0, 203.0);
		auto widthInputPosition = Vec(53.0, 203.0);
		auto oddSkewInputPosition = Vec(93.0, 203.0);
		auto evenSkewInputPosition = Vec(133.0, 203.0);
		auto gainInputPosition = Vec(13.0, 263.0);
		auto decayInputPosition = Vec(53.0, 263.0);
		auto balanceInputPosition = Vec(93.0, 263.0);
		auto filterInputPosition = Vec(133.0, 263.0);
		auto pitchInputPosition = Vec(13.0, 323.0);
		auto syncInputPosition = Vec(53.0, 323.0);

		auto audioOutputPosition = Vec(263.0, 323.0);

		auto sineLightPosition = Vec(111.0, 337.5);
		auto cosineLightPosition = Vec(143.0, 337.5);
		// end generated by svg_widgets.rb

		addParam(ParamWidget::create<Knob38>(frequencyParamPosition, module, Additator::FREQUENCY_PARAM, -5.0, 5.0, 0.0));
		addParam(ParamWidget::create<Knob38>(partialsParamPosition, module, Additator::PARTIALS_PARAM, 1.0, module->maxPartials, module->maxPartials / 10.0f));
		addParam(ParamWidget::create<Knob38>(widthParamPosition, module, Additator::WIDTH_PARAM, 0.0, module->maxWidth, module->maxWidth / 2.0f));
		addParam(ParamWidget::create<Knob26>(oddSkewParamPosition, module, Additator::ODD_SKEW_PARAM, -module->maxSkew, module->maxSkew, 0.0));
		addParam(ParamWidget::create<Knob26>(evenSkewParamPosition, module, Additator::EVEN_SKEW_PARAM, -module->maxSkew, module->maxSkew, 0.0));
		addParam(ParamWidget::create<Knob38>(
			gainParamPosition,
			module,
			Additator::GAIN_PARAM,
			module->minAmplitudeNormalization,
			module->maxAmplitudeNormalization,
			(module->maxAmplitudeNormalization - module->minAmplitudeNormalization) / 2.0f + module->minAmplitudeNormalization
		));
		addParam(ParamWidget::create<Knob38>(
			decayParamPosition,
			module,
			Additator::DECAY_PARAM,
			module->minDecay,
			module->maxDecay,
			(module->maxDecay - module->minDecay) / 2.0f + module->minDecay
		));
		addParam(ParamWidget::create<Knob26>(balanceParamPosition, module, Additator::BALANCE_PARAM, -1.0, 1.0, 0.0));
		addParam(ParamWidget::create<Knob26>(
			filterParamPosition,
			module,
			Additator::FILTER_PARAM,
			module->minFilter,
			module->maxFilter,
			(module->maxFilter - module->minFilter) / 2.0f + module->minFilter
		));
		addParam(ParamWidget::create<StatefulButton9>(phaseParamPosition, module, Additator::PHASE_PARAM, 1.0, 2.0, 1.0));

		addInput(Port::create<Port24>(partialsInputPosition, Port::INPUT, module, Additator::PARTIALS_INPUT));
		addInput(Port::create<Port24>(widthInputPosition, Port::INPUT, module, Additator::WIDTH_INPUT));
		addInput(Port::create<Port24>(oddSkewInputPosition, Port::INPUT, module, Additator::ODD_SKEW_INPUT));
		addInput(Port::create<Port24>(evenSkewInputPosition, Port::INPUT, module, Additator::EVEN_SKEW_INPUT));
		addInput(Port::create<Port24>(gainInputPosition, Port::INPUT, module, Additator::GAIN_INPUT));
		addInput(Port::create<Port24>(decayInputPosition, Port::INPUT, module, Additator::DECAY_INPUT));
		addInput(Port::create<Port24>(balanceInputPosition, Port::INPUT, module, Additator::BALANCE_INPUT));
		addInput(Port::create<Port24>(filterInputPosition, Port::INPUT, module, Additator::FILTER_INPUT));
		addInput(Port::create<Port24>(pitchInputPosition, Port::INPUT, module, Additator::PITCH_INPUT));
		addInput(Port::create<Port24>(syncInputPosition, Port::INPUT, module, Additator::SYNC_INPUT));

		addOutput(Port::create<Port24>(audioOutputPosition, Port::OUTPUT, module, Additator::AUDIO_OUTPUT));

		addChild(ModuleLightWidget::create<TinyLight<GreenLight>>(sineLightPosition, module, Additator::SINE_LIGHT));
		addChild(ModuleLightWidget::create<TinyLight<GreenLight>>(cosineLightPosition, module, Additator::COSINE_LIGHT));
	}
};

Model* modelAdditator = Model::create<Additator, AdditatorWidget>("Bogaudio", "Bogaudio-Additator", "Additator");
